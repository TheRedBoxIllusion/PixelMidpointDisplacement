using System;
using System.Collections.Generic;

namespace PixelMidpointDisplacement {

    /*
     * ========================================
     * 
     * Biome Parent Classes
     * 
     * Biome is the general biome parent class, the world is made up of a list of biomes
     * Subterranean Biome is a class for all biomes that spawn seperate from the surface layer of the world (could be high up) 
     * 
     * ========================================
    */
    public class Biome
    {

        //+++++++++++++++
        //Brownian motion variables:
        public List<BlockThresholdValues> blockThresholdVariables;
        public BlockGenerationVariables[] ores;

        //This is the array of block variables that is generated by the algorithm
        public BlockGenerationVariables[,] brownianMotionArray;

        int maxAttempts = 15;
        //++++++++++++++
        int spawnableOffscreenDistance = 30;


        //++++++++++++++
        //Midpoint Displacement variables:
        public List<(double, double)> initialPoints = new List<(double, double)>();
        public double initialIterationOffset;
        public double decayPower;
        public int iterations;
        public int positiveWeight;
        //++++++++++++++

        public int maxBiomeEntityCount;
        public int currentBiomeEntityCount;

        public int maxSpawnAttempts = 30;

        public List<BiomeSpawnableEntityVariables> spawnableEntities;
        public List<BiomeSpawnableStructureVariables> spawnableStructures = new List<BiomeSpawnableStructureVariables>();
        public List<BiomeSpawnableFluidVariables> spawnableFluids = new List<BiomeSpawnableFluidVariables>();
        public List<BiomeSpawnableDecorationVariables> spawnableDecorations = new List<BiomeSpawnableDecorationVariables>();

        public WorldGenerator worldGenerator;

        public int backgroundBlockID;

        public (int x, int y) biomeOffset;
        (int width, int height) worldDimensions;
        public (int width, int height) biomeDimensions;

        //+++++++++++++
        public Sky biomeSky;

        public Biome((double x, double y) rightMostTerrainPoint, WorldGenerator wg, (int x, int y) biomeOffset, (int x, int y) biomeDimensions)
        {
            //Initialise various variables
            initialPoints = new List<(double, double)>();
            initialPoints.Add(rightMostTerrainPoint);
            worldGenerator = wg;
            this.biomeOffset = biomeOffset;
            this.biomeDimensions = biomeDimensions;

        }
        //For the stencils
        public Biome() { }

        public void generateSurfaceTerrain()
        {
            MidpointDisplacementAlgorithm mda = new MidpointDisplacementAlgorithm(initialPoints, initialIterationOffset, decayPower, iterations, positiveWeight);
            //Should by nature be in absolute dimensions (aka. don't have to worry about the location of the biome)
            pointsToBlocks(mda.midpointAlgorithm());

        }
        public void generateFluids()
        {
            //Go through each item in the spawnable fluids list and attempt to generate a fluid lake from it
            //If the maxLakeSize is 1, then just spawn it anywhere on an edge of a cave (eg. where an air and a solid block meets)
            //If the maxLakeSize is greater than that, find a random air pocket (cave) and then search downwards until you reach a bottom
            //  -> searching sideways finds a book end on both sides. Then fill that volume. Go up, and re-check the sides to see if you find book ends. If the volume that you find is greater than the maxLakeSide, don't fill it, or if there isn't a book end on both sides within the maxLakeVolume
            Random r = new Random();

            for (int i = 0; i < spawnableFluids.Count; i++)
            {
                int numberOfLakes = (int)(biomeDimensions.width * biomeDimensions.height * (spawnableFluids[i].density / 100.0));
                for (int n = 0; n < numberOfLakes; n++)
                {
                    //Add some more logic for fluids of only 1 size: creating water falls

                    if (spawnableFluids[i].maxLakeSize > 1)
                    {
                        //Attempt a set number of times to find an air pocket within the biome:
                        bool foundASpot = false;
                        int attemptCount = 0;

                        int x = 0;
                        int y = 0;
                        while (!foundASpot && attemptCount < maxSpawnAttempts)
                        {
                            attemptCount += 1;
                            //Randomly generate a spot:
                            x = r.Next(0, biomeDimensions.width);
                            y = 0;
                            //If it's a surface biome:
                            if (biomeOffset.y == 0)
                            {
                                y = r.Next(worldGenerator.surfaceHeight[x] + spawnableFluids[i].yMin, worldGenerator.surfaceHeight[x] + spawnableFluids[i].yMax);
                            }
                            else
                            {
                                //Else if it's not on the surface, base it on the biome dimensions:
                                if (spawnableFluids[i].yMax < biomeDimensions.height)
                                {
                                    y = r.Next(biomeOffset.y + spawnableFluids[i].yMin, biomeOffset.y + spawnableFluids[i].yMax);
                                }
                                else
                                {
                                    y = r.Next(biomeOffset.y + spawnableFluids[i].yMin, biomeOffset.y + biomeDimensions.height);

                                }
                            }
                            if (x >= 0 && x < worldGenerator.worldArray.GetLength(0) && y >= 0 && y < worldGenerator.worldArray.GetLength(1))
                            {
                                if (worldGenerator.worldArray[x, y] == 0)
                                {
                                    foundASpot = true;
                                }
                            }
                        }
                        //The spot is air, and thus yay!
                        //Use the world generator to find a local min
                        (int minX, int minY) = worldGenerator.findLocalMin(x, y);
                        int lowestX = minX;
                        //If the returned point isn't the error value
                        if (!(minX == 0 && minY == 0))
                        {
                            //Fill upwards:
                            //Search sideways until you hit a wall, then go the other way. Count the number of blocks here, and reduce the lakeSize by that value

                            int searchDirection = 0;
                            int oppositeDirection = 0;
                            int resetX = minX;
                            int resetY = minY;

                            int layerSize = 0;

                            bool hasFaulted = false;

                            int remainingLakeVolume = spawnableFluids[i].maxLakeSize;

                            while (remainingLakeVolume >= 0 && remainingLakeVolume > layerSize && !hasFaulted)
                            {
                                bool foundFullLayer = false;
                                bool hitAWallLeft = false;
                                bool hitAWallRight = false;
                                List<(int x, int y)> blocksToSet = new List<(int, int)>();
                                while (!foundFullLayer && remainingLakeVolume > layerSize && !hasFaulted)
                                {
                                    layerSize += 1;

                                    if (searchDirection == 0)
                                    {
                                        searchDirection = (2 * r.Next(2)) - 1; //Randomly pick -1 or 1
                                        resetX = minX;
                                        resetY = minY;
                                        oppositeDirection = -1 * searchDirection;
                                    }
                                    //Have to include the "search direction" aspect because the reset values are obviously set to the fluid
                                    if (minX + searchDirection >= 0 && minX + searchDirection < worldGenerator.worldArray.GetLength(0) && minY >= 0 && minY < worldGenerator.worldArray.GetLength(1))
                                    {
                                        if (minY < worldGenerator.worldArray.GetLength(1) - 1 ? worldGenerator.worldArray[minX, minY + 1] == 0 : false)
                                        {
                                            hasFaulted = true;
                                        }
                                        else
                                        {
                                            if (worldGenerator.worldArray[minX, minY] == 0)
                                            {
                                                blocksToSet.Add((minX, minY));
                                                minX += searchDirection;
                                            }
                                            else
                                            {
                                                //Hit a wall!
                                                if (searchDirection == -1)
                                                {
                                                    hitAWallLeft = true;
                                                }
                                                else
                                                {
                                                    hitAWallRight = true;
                                                }


                                                if (hitAWallLeft && hitAWallRight)
                                                {
                                                    foundFullLayer = true;
                                                    searchDirection = 0;
                                                }
                                                else
                                                {
                                                    searchDirection = oppositeDirection;
                                                    minX = resetX + searchDirection;
                                                    minY = resetY;
                                                }
                                            }
                                        }


                                    }
                                }
                                if (foundFullLayer)
                                {
                                    for (int b = 0; b < blocksToSet.Count; b++)
                                    {
                                        worldGenerator.worldArray[blocksToSet[b].x, blocksToSet[b].y] = spawnableFluids[i].fluid.ID;
                                    }
                                }

                                minX = lowestX;
                                minY -= 1;
                                blocksToSet.Clear();
                                searchDirection = 0;
                                remainingLakeVolume -= layerSize;


                                layerSize = 0;
                            }

                        }
                    }
                    else
                    {
                        bool foundASpot = false;
                        int attemptCount = 0;

                        int x = 0;
                        int y = 0;
                        while (!foundASpot && attemptCount < maxSpawnAttempts)
                        {
                            attemptCount += 1;
                            //Randomly generate a spot:
                            x = r.Next(0, biomeDimensions.width);
                            y = 0;
                            //If it's a surface biome:
                            if (biomeOffset.y == 0)
                            {
                                y = r.Next(worldGenerator.surfaceHeight[x] + spawnableFluids[i].yMin, worldGenerator.surfaceHeight[x] + spawnableFluids[i].yMax);
                            }
                            else
                            {
                                //Else if it's not on the surface, base it on the biome dimensions:
                                if (spawnableFluids[i].yMax < biomeDimensions.height)
                                {
                                    y = r.Next(biomeOffset.y + spawnableFluids[i].yMin, biomeOffset.y + spawnableFluids[i].yMax);
                                }
                                else
                                {
                                    y = r.Next(biomeOffset.y + spawnableFluids[i].yMin, biomeOffset.y + biomeDimensions.height);

                                }
                            }
                            if (x >= 0 && x < worldGenerator.worldArray.GetLength(0) && y >= 0 && y < worldGenerator.worldArray.GetLength(1))
                            {
                                if (worldGenerator.worldArray[x, y] == 0)
                                {
                                    foundASpot = true;
                                }
                            }
                        }
                        //Found a spot (presumably):
                        if (foundASpot)
                        {

                            //Search sideways until hitting a solid block: then, convert that block to the fluid
                            int searchDirection = (2 * r.Next(2)) - 1; //Randomly pick -1 or 1

                            bool foundAWall = false;
                            bool faulted = false;

                            while (!foundAWall && !faulted)
                            {
                                if (x + searchDirection >= 0 && x + searchDirection < worldGenerator.worldArray.GetLength(0) && y >= 0 && y < worldGenerator.worldArray.GetLength(1))
                                {
                                    x += searchDirection;
                                    if (worldGenerator.worldArray[x, y] != 0)
                                    {
                                        //Found a wall:
                                        worldGenerator.worldArray[x, y] = spawnableFluids[i].fluid.ID;
                                        foundAWall = true;
                                    }
                                }
                                else
                                {
                                    faulted = true;
                                }
                            }
                        }

                    }


                }
            }
        }
        public void generateBackground()
        {
            for (int x = biomeOffset.x; x < biomeOffset.x + biomeDimensions.width; x++)
            {
                for (int y = biomeOffset.y; y < biomeOffset.y + biomeDimensions.height; y++)
                {
                    if (x >= 0 && x < worldGenerator.surfaceHeight.Length && y >= 0 && y < worldGenerator.backgroundArray.GetLength(1))
                    {
                        if (y >= worldGenerator.surfaceHeight[x])
                        {
                            worldGenerator.backgroundArray[x, y] = this.backgroundBlockID;
                        }
                        else
                        {
                            worldGenerator.backgroundArray[x, y] = 0;
                        }
                    }
                }
            }
        }
        public void generateStructures()
        {
            for (int i = 0; i < spawnableStructures.Count; i++)
            {
                int structureCount = (int)((spawnableStructures[i].density / 100f) * biomeDimensions.width * biomeDimensions.height);

                Random r = new Random();
                //Randomsie the amount of structures, within a certain range;
                structureCount = r.Next(structureCount / 2, structureCount);
                for (int s = 0; s < structureCount; s++)
                {

                    //Generate an x and y, ensuring that they are within the biome and the specified spawn dimensions
                    int x = r.Next(biomeOffset.x, biomeOffset.x + biomeDimensions.width);
                    int y = r.Next(biomeOffset.y + spawnableStructures[i].yMin, biomeOffset.y + spawnableStructures[i].yMax);

                    if (x >= 0 && x < worldGenerator.worldArray.GetLength(0) && y + worldGenerator.surfaceHeight[x] >= 0 && y + worldGenerator.surfaceHeight[x] < worldGenerator.worldArray.GetLength(1))
                    {
                        spawnableStructures[i].structure.placeStructure(this, x, y + worldGenerator.surfaceHeight[x]);
                    }
                }
            }
        }

        public void generateOres()
        {
            brownianMotionArray = new BlockGenerationVariables[biomeDimensions.width, biomeDimensions.height];
            //Only seed the algorithm, implement it into the worlds array and add the ores to a list
            seededBrownianMotion(ores, maxAttempts);

            for (int x = 0; x < brownianMotionArray.GetLength(0); x++)
            {
                for (int y = 0; y < brownianMotionArray.GetLength(1); y++)
                {
                    int globalX = x + biomeOffset.x;
                    int globalY = y + biomeOffset.y;

                    if (globalX > 0 && globalX < worldGenerator.brownianMotionArray.GetLength(0) && globalY > 0 && globalY < worldGenerator.brownianMotionArray.GetLength(1))
                    {
                        worldGenerator.brownianMotionArray[globalX, globalY] = brownianMotionArray[x, y];
                    }
                }
            }

        }

        public void generateDecorations()
        {
            //Two ways that it can be random directions:
            //Each movement is in a random direction
            //  -> Pros: Can go in many directions and is more interesting. Cons: Can make them be closer than the 'minimum' distance

            //When generating, each decoration moves in a set direction - Current technique
            if (spawnableDecorations.Count > 0)
            {
                foreach (BiomeSpawnableDecorationVariables decorationVar in spawnableDecorations)
                {
                    Random r = new Random();
                    //Calculate the number of decorations:
                    int numberOfDecorations = 0;
                    if (decorationVar.spawnOnSurface)
                    {
                        double averageCount = (decorationVar.density / 100.0) * biomeDimensions.width;
                        numberOfDecorations = r.Next((int)(averageCount * 0.9), (int)(averageCount * 1.1));
                    }
                    else
                    {
                        double averageCount = (decorationVar.density / 100.0) * biomeDimensions.width * biomeDimensions.height;
                        numberOfDecorations = r.Next((int)(averageCount * 0.9), (int)(averageCount * 1.1));
                    }

                    int sign = r.Next(2) * 2 - 1;


                    if (decorationVar.spawnOnSurface)
                    {
                        int x = r.Next(0, biomeDimensions.width) + biomeOffset.x;
                        int y = 0;
                        if (x >= 0 && x < worldGenerator.worldArray.GetLength(0))
                        {
                            y = worldGenerator.surfaceHeight[x];
                        }
                        int lastX = x;
                        int lastY = y;
                        for (int i = 0; i < numberOfDecorations; i++)
                        {

                            int maxAttemptCount = 15;
                            int attemptCount = 0;
                            bool generatedDecoration = false;
                            while (!generatedDecoration && attemptCount < maxAttemptCount)
                            {
                                attemptCount += 1;

                                //Currently only moves right, so make it either positive or negative randomly
                                x = sign * r.Next(decorationVar.minToNextDecoration, decorationVar.maxToNextDecoration) + lastX;
                                if (x >= 0 && x < worldGenerator.worldArray.GetLength(0))
                                {
                                    y = worldGenerator.surfaceHeight[x];
                                }

                                if (decorationVar.yMin < y && y < decorationVar.yMax)
                                {
                                    if (x > 0 && x < worldGenerator.worldArray.GetLength(0) - 1 && y > 0 && y < worldGenerator.worldArray.GetLength(1) - 1)
                                    {
                                        generatedDecoration = decorationVar.decoration.generate(x, y, worldGenerator);
                                    }
                                }
                            }

                            lastX = x;
                            lastY = y;
                        }
                    }
                    else
                    {
                        int x = r.Next(0, biomeDimensions.width) + biomeOffset.x;
                        int y = r.Next(0, biomeDimensions.height) + biomeOffset.y;

                        int lastX = x;
                        int lastY = y;
                        for (int i = 0; i < numberOfDecorations; i++)
                        {
                            int maxAttemptCount = 15;
                            int attemptCount = 0;
                            bool generatedDecoration = false;
                            while (!generatedDecoration && attemptCount < maxAttemptCount)
                            {
                                attemptCount += 1;
                                x = (r.Next() * 2 - 1) * r.Next(decorationVar.minToNextDecoration, decorationVar.maxToNextDecoration) + lastX;
                                y = (r.Next() * 2 - 1) * r.Next(decorationVar.minToNextDecoration, decorationVar.maxToNextDecoration) + lastY;

                                if (decorationVar.yMin < y && y < decorationVar.yMax)
                                {
                                    if (x >= 0 && x < worldGenerator.worldArray.GetLength(0) && y >= 0 && y < worldGenerator.worldArray.GetLength(1))
                                    {
                                        generatedDecoration = decorationVar.decoration.generate(x, y, worldGenerator);
                                    }
                                }
                            }

                            lastX = x;
                            lastY = y;
                        }
                    }
                }
            }
        }
        private void seededBrownianMotion(BlockGenerationVariables[] oresArray, int attemptCount)
        {
            SeededBrownianMotion sbm = new SeededBrownianMotion();
            brownianMotionArray = sbm.seededBrownianMotion(brownianMotionArray, oresArray);
            //brownianMotionArray = sbm.brownianAlgorithm(brownianMotionArray, attemptCount);
        }


        private void pointsToBlocks(List<(double x, double y)> pointList)
        {
            //Convert each point to within the grid-coordinates, then set the worldArray to 1 wherever each lands

            double distanceBetweenPoints = Math.Sqrt(Math.Pow(2, (pointList[0].x - pointList[1].x) + Math.Pow(2, pointList[0].y - pointList[1].y)));

            int numOfInterpolations = 0;

            if (distanceBetweenPoints > Math.Sqrt(2) * worldGenerator.worldContext.pixelsPerBlock)
            {
                numOfInterpolations = (int)(distanceBetweenPoints / worldGenerator.worldContext.pixelsPerBlock) - 1;
            }

            for (int i = 0; i < pointList.Count; i++)
            {

                int gridX = (int)Math.Floor(pointList[i].x / worldGenerator.worldContext.pixelsPerBlock);
                int gridY = (int)Math.Floor(pointList[i].y / worldGenerator.worldContext.pixelsPerBlock);

                if (gridX < 0)
                {
                    gridX = 0;
                }
                else if (gridX >= worldGenerator.worldArray.GetLength(0))
                {
                    gridX = worldGenerator.worldArray.GetLength(0) - 1;
                }
                if (gridY < 0)
                {
                    gridY = 0;
                }
                else if (gridY >= worldGenerator.worldArray.GetLength(1))
                {
                    gridY = worldGenerator.worldArray.GetLength(1) - 1;
                }

                for (int y = gridY; y < worldGenerator.worldArray.GetLength(1); y++)
                {
                    worldGenerator.worldArray[gridX, y] = 1;

                    if (worldGenerator.worldArray[gridX, y] != 0)
                    {
                        if (worldGenerator.surfaceHeight[gridX] > y)
                        {
                            worldGenerator.surfaceHeight[gridX] = y;
                        }

                    }
                }
            }

        }

        public double changeThresholdByDepth((double x, double y) position)
        {
            return changeThresholdByDepth(blockThresholdVariables, position);
        }
        private double changeThresholdByDepth(List<BlockThresholdValues> blockThresholdVariables, (double x, double y) position)
        {
            double blockThreshold = 1;

            for (int i = blockThresholdVariables.Count - 1; i >= 0; i--)
            {
                if (position.y >= blockThresholdVariables[i].maximumY)
                {
                    double calculatedYWeight = position.y * blockThresholdVariables[i].absoluteYHeightWeight + (position.y - worldGenerator.surfaceHeight[(int)position.x]) * blockThresholdVariables[i].relativeYHeightWeight;
                    blockThreshold = blockThresholdVariables[i].blockThreshold - blockThresholdVariables[i].decreasePerY * calculatedYWeight;
                    if (blockThreshold > blockThresholdVariables[i].maximumThreshold)
                    {
                        blockThreshold = blockThresholdVariables[i].maximumThreshold;
                    }
                    else if (blockThreshold < blockThresholdVariables[i].minimumThreshold)
                    {
                        blockThreshold = blockThresholdVariables[i].minimumThreshold;
                    }
                    break;
                }
            }

            return blockThreshold;
        }

        public virtual void tickBiome(WorldContext w)
        {
            Random r = new Random();

            //Go through the list of entities and check if it should be spawned
            if (spawnableEntities != null)
            {
                for (int i = 0; i < spawnableEntities.Count; i++)
                {
                    if (spawnableEntities[i].yMax > (int)Math.Floor((-w.screenSpaceOffset.y) / (double)w.pixelsPerBlock) - w.surfaceHeight[(int)Math.Floor(-w.screenSpaceOffset.x / (double)w.pixelsPerBlock)] && spawnableEntities[i].yMin < (int)Math.Floor(-w.screenSpaceOffset.y / (double)w.pixelsPerBlock) - w.surfaceHeight[(int)Math.Floor(-w.screenSpaceOffset.x / (double)w.pixelsPerBlock)])
                    {
                        if (currentBiomeEntityCount < maxBiomeEntityCount && spawnableEntities[i].currentSpecificEntityCount < spawnableEntities[i].maxSpecificEntityCount)
                        {
                            //Check to spawn the entity
                            double percentage = r.NextDouble() * 100;
                            if (percentage <= spawnableEntities[i].spawnProbability)
                            {
                                //Adjust the current specific entity count

                                currentBiomeEntityCount += 1;
                                spawnableEntities[i].currentSpecificEntityCount += 1;


                                //Adjust entity location:


                                int xLoc = r.Next((int)Math.Floor(-w.screenSpaceOffset.x / (double)w.pixelsPerBlock) - spawnableOffscreenDistance, (int)Math.Floor((w.applicationWidth - w.screenSpaceOffset.x) / (double)w.pixelsPerBlock) + spawnableOffscreenDistance);
                                int yLoc = r.Next((int)Math.Floor(-w.screenSpaceOffset.y / (double)w.pixelsPerBlock) - spawnableOffscreenDistance, (int)Math.Floor((w.applicationHeight - w.screenSpaceOffset.y) / (double)w.pixelsPerBlock) + spawnableOffscreenDistance);

                                //Find a spawnable location:
                                bool foundALocation = false;
                                int currentSpawnAttemptCount = 0;
                                while (!foundALocation && currentSpawnAttemptCount < maxSpawnAttempts)
                                {
                                    currentSpawnAttemptCount += 1;
                                    xLoc = r.Next((int)Math.Floor(-w.screenSpaceOffset.x / (double)w.pixelsPerBlock) - spawnableOffscreenDistance, (int)Math.Floor((w.applicationWidth - w.screenSpaceOffset.x) / (double)w.pixelsPerBlock) + spawnableOffscreenDistance);
                                    yLoc = r.Next((int)Math.Floor(-w.screenSpaceOffset.y / (double)w.pixelsPerBlock) - spawnableOffscreenDistance, (int)Math.Floor((w.applicationHeight - w.screenSpaceOffset.y) / (double)w.pixelsPerBlock) + spawnableOffscreenDistance);
                                    if (spawnableEntities[i].spawnOnSurface)
                                    {
                                        yLoc = w.surfaceHeight[xLoc] - (int)Math.Ceiling(spawnableEntities[i].entity.height - 1);
                                    }

                                    //Check if that location is somewhere that the entity can spawn:
                                    //Off-screen
                                    if ((xLoc < Math.Floor(-w.screenSpaceOffset.x / (double)w.pixelsPerBlock) || xLoc > Math.Floor((w.applicationWidth - w.screenSpaceOffset.x) / (double)w.pixelsPerBlock)) && (yLoc < Math.Floor(-w.screenSpaceOffset.y / (double)w.pixelsPerBlock) || yLoc > Math.Floor((w.applicationHeight - w.screenSpaceOffset.y) / (double)w.pixelsPerBlock)))
                                    {
                                        //Sufficient air for the entity to exist in
                                        bool isASolidBlockInSpawnLocation = false;
                                        for (int x = -1; x < (int)Math.Ceiling(spawnableEntities[i].entity.width); x++)
                                        {
                                            for (int y = -1; y < (int)Math.Ceiling(spawnableEntities[i].entity.height); y++)
                                            {
                                                if (xLoc + x >= 0 && xLoc + x < w.worldArray.GetLength(0) && yLoc + y >= 0 && yLoc + y < w.worldArray.GetLength(1))
                                                    if (w.worldArray[xLoc + x, yLoc + y].ID != (int)blockIDs.air)
                                                    {
                                                        isASolidBlockInSpawnLocation = true;
                                                    }
                                            }
                                        }
                                        bool isOnSolidGround = false;

                                        int integerHeight = (int)Math.Ceiling(spawnableEntities[i].entity.height);
                                        if (xLoc >= 0 && xLoc < w.worldArray.GetLength(0) && yLoc + integerHeight >= 0 && yLoc + integerHeight < w.worldArray.GetLength(1))
                                        {
                                            isOnSolidGround = !w.worldArray[xLoc, yLoc + integerHeight].isBlockTransparent;
                                        }

                                        if (!isASolidBlockInSpawnLocation && isOnSolidGround)
                                        {
                                            foundALocation = true;
                                            SpawnableEntity entity = spawnableEntities[i].entity.copyEntity() as SpawnableEntity;
                                            entity.setBiome(this, i);
                                            entity.x = xLoc * w.pixelsPerBlock;
                                            entity.y = yLoc * w.pixelsPerBlock;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        public virtual Biome generateBiomeCopy((double, double) rightMostTerrainPoint, WorldGenerator wg, (int x, int y) biomeOffset, (int width, int height) biomeDimensions)
        {
            return new Biome(rightMostTerrainPoint, wg, biomeOffset, biomeDimensions);
        }
    }
    public class SubterraneanBiome : Biome
    {
        //A biome that exists only under the surface of the world


        public int x;
        public int y;

        public int biomesPerWorld;

        public int externalBiomeIndex;

        public List<Type> biomesThisCanSpawnIn = new List<Type>();

        public int minY;
        public int maxY;

        public SubterraneanBiome((double x, double y) rightMostTerrainPoint, WorldGenerator wg, (int x, int y) biomeOffset, (int x, int y) biomeDimensions) : base(rightMostTerrainPoint, wg, biomeOffset, biomeDimensions)
        {
            x = biomeOffset.x;
            y = biomeOffset.y;
        }

        public SubterraneanBiome() { }

        public void setBiomeLocation(int x, int y)
        {
            this.x = x;
            this.y = y;
            biomeOffset.x = x;
            biomeOffset.y = y;
        }

        public override Biome generateBiomeCopy((double, double) rightMostTerrainPoint, WorldGenerator wg, (int x, int y) biomeOffset, (int width, int height) biomeDimensions)
        {
            return new SubterraneanBiome(rightMostTerrainPoint, wg, biomeOffset, biomeDimensions);
        }
    }

    /*
     * ========================================
     * 
     * Surface Biomes
     * 
     * Biomes that spawn across the world from top to bottom. They compose the primary content of the world
     * 
     * MeadowBiome
     * MountainBiome
     * ========================================
    */

    public class MeadowBiome : Biome
    {

        public MeadowBiome((double x, double y) rightMostTerrainPoint, WorldGenerator wg, (int x, int y) biomeOffset, (int x, int y) biomeDimensions) : base(rightMostTerrainPoint, wg, biomeOffset, biomeDimensions)
        {
            //Generate the randomised variables
            initialIterationOffset = 90;
            decayPower = 1.1;
            iterations = 10;
            positiveWeight = 30;

            backgroundBlockID = 1;

            maxBiomeEntityCount = 30;

            biomeSky = new Sky((int)spriteSheetIDs.skyLayers, 5, new List<double>() { 1, 0.6, 0.4, 0.04, 0 }, new Microsoft.Xna.Framework.Vector2(480, 270));

            ores = new BlockGenerationVariables[]{
            new BlockGenerationVariables(seedDensity : 1, block : new Block(ID : 2), maxSingleSpread : 8, oreVeinSpread : 360), //Dirt
            new BlockGenerationVariables(0.1, new OreBlock((int)blockIDs.ironOre), 1, 4, (0.3, 0.6, 0.1, 0.0, 0.0, 0.0, 0.0, 0.0)),
            new BlockGenerationVariables(0.3, new Block(1), 6, 24)
            };


            blockThresholdVariables = new List<BlockThresholdValues>(){
            new BlockThresholdValues(blockThreshold : 0.9, maximumY : 0, decreasePerY : 0.005, maximumThreshold : 0.9, minimumThreshold : 0.48, absoluteYHeightWeight : 0, relativeYHeightWeight : 1),
            new BlockThresholdValues(0.9, 130, 0.005, 0.9, 0.48, 0.3, 1),

            new BlockThresholdValues(0.9, 150, 0.01, 0.9, 0.48, 1, 0),

            new BlockThresholdValues(0.9, 200, 0.005, 0.9, 0.48, 0.2, 1),
            new BlockThresholdValues(0.9, 210, 0.005, 0.9, 0.48, 0, 1)
            };

            spawnableStructures = new List<BiomeSpawnableStructureVariables>()
            {
                new BiomeSpawnableStructureVariables(new Structure("House"), 0.05, biomeDimensions.y, 0)
            };

            spawnableEntities = new List<BiomeSpawnableEntityVariables>() {
                new BiomeSpawnableEntityVariables(new EvilClone(wg.worldContext, wg.worldContext.player), 50, 0, 20, 500, 10, false)
            };

            spawnableFluids = new List<BiomeSpawnableFluidVariables>()
            {
                new BiomeSpawnableFluidVariables(new FluidBlock((int)blockIDs.water), 0.01, 600, 1, 1),
                new BiomeSpawnableFluidVariables(new FluidBlock((int)blockIDs.water), 0.01, 600, 1, 20),
                new BiomeSpawnableFluidVariables(new FluidBlock((int)blockIDs.water), 0.05, 0, -30, 60)
            };

            spawnableDecorations = new List<BiomeSpawnableDecorationVariables>() {
                new BiomeSpawnableDecorationVariables(new TreeGeneration(), 3, 4, 15, 400, 0, true),
                new BiomeSpawnableDecorationVariables(new TreeGeneration(), 3, 4, 15, 400, 0, true),
                new BiomeSpawnableDecorationVariables(new BushGeneration(), 10, 3, 25, 400, 0, true),
                new BiomeSpawnableDecorationVariables(new BigBushGeneration(), 10, 3, 25, 400, 0, true)

            };

            //Generate a random biome Width:
            Random r = new Random();

            int biomeVariant = r.Next(2);
            switch (biomeVariant)
            {
                case 0:
                    this.biomeDimensions.width = r.Next(100, 200);

                    break;
                case 1:
                    this.biomeDimensions.width = r.Next(200, 350);
                    break;
            }

            initialPoints.Add((rightMostTerrainPoint.x + this.biomeDimensions.width * wg.worldContext.pixelsPerBlock, rightMostTerrainPoint.y));
        }
        public MeadowBiome() { }
        public override Biome generateBiomeCopy((double, double) rightMostTerrainPoint, WorldGenerator wg, (int x, int y) biomeOffset, (int width, int height) biomeDimensions)
        {
            return new MeadowBiome(rightMostTerrainPoint, wg, biomeOffset, biomeDimensions);
        }
    }
    public class MountainBiome : Biome
    {
        public MountainBiome((double x, double y) rightMostTerrainPoint, WorldGenerator wg, (int x, int y) biomeOffset, (int x, int y) biomeDimensions) : base(rightMostTerrainPoint, wg, biomeOffset, biomeDimensions)
        {
            //Generate the randomised variables
            iterations = 10;
            decayPower = 0.9;
            positiveWeight = 80;
            initialIterationOffset = 100;

            backgroundBlockID = 1;



            ores = new BlockGenerationVariables[] {
                new BlockGenerationVariables(1, new Block((int)blockIDs.stone), 8, 80),
                new BlockGenerationVariables(0.1, new Block((int)blockIDs.dirt), 3, 10)
            };

            blockThresholdVariables = new List<BlockThresholdValues> {
                new BlockThresholdValues(blockThreshold : 0.9, maximumY : 0, decreasePerY : 0.005, maximumThreshold : 0.9, minimumThreshold : 0.45, absoluteYHeightWeight : 0.3, relativeYHeightWeight : 0.7 ),
                new BlockThresholdValues(blockThreshold : 0.48, maximumY : 400, decreasePerY : 0.001, maximumThreshold : 0.48, minimumThreshold : 0.4, absoluteYHeightWeight : 0, relativeYHeightWeight : 1)
            };

            spawnableStructures = new List<BiomeSpawnableStructureVariables>() {
                new BiomeSpawnableStructureVariables(new Structure("Shrine"), 0.005, biomeDimensions.y, 200)
            };

            spawnableFluids = new List<BiomeSpawnableFluidVariables>() {
                new BiomeSpawnableFluidVariables(new FluidBlock((int)blockIDs.water), 0.01, 400, 10, 1)
            };


            this.biomeDimensions.width = new Random().Next(200, 400);


            initialPoints.Add((rightMostTerrainPoint.x + (this.biomeDimensions.width * wg.worldContext.pixelsPerBlock) / 2, rightMostTerrainPoint.y - 500)); //A central peak
            initialPoints.Add((rightMostTerrainPoint.x + this.biomeDimensions.width * wg.worldContext.pixelsPerBlock, rightMostTerrainPoint.y));
        }

        public MountainBiome() { }

        public override Biome generateBiomeCopy((double, double) rightMostTerrainPoint, WorldGenerator wg, (int x, int y) biomeOffset, (int width, int height) biomeDimensions)
        {
            return new MountainBiome(rightMostTerrainPoint, wg, biomeOffset, biomeDimensions);
        }

    }

    /*
     * ========================================
     * 
     * Subterranean Biomes
     * 
     *  Biomes that typically spawn underneath the surface biomes. They can be relatively small, or span across several surface biomes. They can spawn in certain biomes and appear as sub-biomes
     *  
     *  CaveBiome
     * ========================================
    */

    public class CaveBiome : SubterraneanBiome
    {

        public CaveBiome((double x, double y) rightMostTerrainPoint, WorldGenerator wg, (int x, int y) biomeOffset, (int x, int y) biomeDimensions) : base(rightMostTerrainPoint, wg, biomeOffset, biomeDimensions)
        {
            ores = new BlockGenerationVariables[] {
                new BlockGenerationVariables(1, new Block((int)blockIDs.stone), 8, 80),
                new BlockGenerationVariables(0.1, new Block((int)blockIDs.dirt), 3, 10)
            };

            blockThresholdVariables = new List<BlockThresholdValues> {
                new BlockThresholdValues(blockThreshold : 0.9, maximumY : 0, decreasePerY : 0.005, maximumThreshold : 0.9, minimumThreshold : 0.45, absoluteYHeightWeight : 0.3, relativeYHeightWeight : 0.7 ),
                new BlockThresholdValues(blockThreshold : 0.48, maximumY : 400, decreasePerY : 0.001, maximumThreshold : 0.48, minimumThreshold : 0.4, absoluteYHeightWeight : 0, relativeYHeightWeight : 1)
            };

            biomesThisCanSpawnIn.Add(typeof(MeadowBiome));

            biomesPerWorld = 5;
            minY = 50;
            maxY = 250;

            backgroundBlockID = 1;

            Random r = new Random();
            this.biomeDimensions.width = r.Next(50, 100);
            this.biomeDimensions.height = r.Next(50, 100);

        }

        public CaveBiome()
        {
            biomesPerWorld = 5;
            minY = 50;
            maxY = 250;
            biomesThisCanSpawnIn.Add(typeof(MeadowBiome));

        }

        public override Biome generateBiomeCopy((double, double) rightMostTerrainPoint, WorldGenerator wg, (int x, int y) biomeOffset, (int width, int height) biomeDimensions)
        {
            return new CaveBiome(rightMostTerrainPoint, wg, biomeOffset, biomeDimensions);
        }
    }

    /*
     * ========================================
     * 
     * Biome Variables
     * 
     *  Classes containing variables that determine the conditions of spawning certain structures, entities or blocks.
     *  Each biome contains a list of spawn variables for the different categories.
     *  
     *  EntityVariables
     *  StructureVariables
     *  FluidVariables
     *  DecorationVariables
     * 
     * ========================================
    */
    public class BiomeSpawnableEntityVariables
    {
        public SpawnableEntity entity;
        public int maxSpecificEntityCount;
        public int currentSpecificEntityCount;
        public double spawnProbability;
        public int yMax;
        public int yMin;
        public bool spawnOnSurface;

        public BiomeSpawnableEntityVariables(SpawnableEntity entity, int maxSpecificEntityCount, int currentSpecificEntityCount, double spawnProbability, int yMax, int yMin, bool spawnOnSurface)
        {
            this.entity = entity;
            this.maxSpecificEntityCount = maxSpecificEntityCount;
            this.currentSpecificEntityCount = currentSpecificEntityCount;
            this.spawnProbability = spawnProbability;
            this.yMax = yMax;
            this.yMin = yMin;
            this.spawnOnSurface = spawnOnSurface;
        }
    }

    public class BiomeSpawnableStructureVariables
    {
        public Structure structure;
        public double density;
        public int yMax;
        public int yMin;

        public BiomeSpawnableStructureVariables(Structure structure, double density, int yMax, int yMin)
        {
            this.structure = structure;
            this.density = density;
            this.yMax = yMax;
            this.yMin = yMin;
        }
    }

    public class BiomeSpawnableFluidVariables
    {
        public FluidBlock fluid;
        public double density;
        public int yMax;
        public int yMin;
        public int maxLakeSize;

        public BiomeSpawnableFluidVariables(FluidBlock fluid, double density, int yMax, int yMin, int maxLakeSize)
        {
            this.fluid = fluid;
            this.density = density;
            this.yMax = yMax;
            this.yMin = yMin;
            this.maxLakeSize = maxLakeSize;
        }
    }

    public class BiomeSpawnableDecorationVariables
    {
        public Decoration decoration;
        public double density;
        public int minToNextDecoration;
        public int maxToNextDecoration;
        public int yMax;
        public int yMin;
        public bool spawnOnSurface;

        public BiomeSpawnableDecorationVariables(Decoration decoration, double density, int minToNextDecoration, int maxToNextDecoration, int yMax, int yMin, bool spawnOnSurface)
        {
            this.decoration = decoration;
            this.density = density;
            this.minToNextDecoration = minToNextDecoration;
            this.maxToNextDecoration = maxToNextDecoration;
            this.yMax = yMax;
            this.yMin = yMin;
            this.spawnOnSurface = spawnOnSurface;
        }
    }
}